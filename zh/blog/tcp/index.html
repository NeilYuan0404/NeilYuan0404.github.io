<!DOCTYPE html>
<html lang="zh" dir="auto" data-theme="auto">

<head><meta charset="utf-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1, shrink-to-fit=no">
<meta name="robots" content="index, follow">
<title>实现TCP发送HTTP请求 | Neil&#39;s Digital Garden</title>
<meta name="keywords" content="TCP, HTTP, 网络编程, C语言">
<meta name="description" content="HTTP协议是最被广泛使用的网络传输协议，所有的www文件都必须遵守这个标准，并且，HTTP基于TCP/IP通信协议来传递数据，本文的主要内容是介绍HTTP请求的的格式，并且使用C语言以TCP的方式来实现请求的发送。">
<meta name="author" content="">
<link rel="canonical" href="https://neilyuan0404.github.io/zh/blog/tcp/">
<link crossorigin="anonymous" href="/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css" integrity="sha256-NDzEgLn/yPBMy&#43;XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as="style">
<link rel="icon" href="https://neilyuan0404.github.io/favicon.ico">
<link rel="icon" type="image/png" sizes="16x16" href="https://neilyuan0404.github.io/favicon-16x16.png">
<link rel="icon" type="image/png" sizes="32x32" href="https://neilyuan0404.github.io/favicon-32x32.png">
<link rel="apple-touch-icon" href="https://neilyuan0404.github.io/apple-touch-icon.png">
<link rel="mask-icon" href="https://neilyuan0404.github.io/safari-pinned-tab.svg">
<meta name="theme-color" content="#2e2e33">
<meta name="msapplication-TileColor" content="#2e2e33">
<link rel="alternate" hreflang="zh" href="https://neilyuan0404.github.io/zh/blog/tcp/">
<noscript>
    <style>
        #theme-toggle,
        .top-link {
            display: none;
        }

    </style>
    <style>
        @media (prefers-color-scheme: dark) {
            :root {
                --theme: rgb(29, 30, 32);
                --entry: rgb(46, 46, 51);
                --primary: rgb(218, 218, 219);
                --secondary: rgb(155, 156, 157);
                --tertiary: rgb(65, 66, 68);
                --content: rgb(196, 196, 197);
                --code-block-bg: rgb(46, 46, 51);
                --code-bg: rgb(55, 56, 62);
                --border: rgb(51, 51, 51);
                color-scheme: dark;
            }

            .list {
                background: var(--theme);
            }

            .toc {
                background: var(--entry);
            }
        }

        @media (prefers-color-scheme: light) {
            .list::-webkit-scrollbar-thumb {
                border-color: var(--code-bg);
            }
        }

    </style>
</noscript>
<script>
    if (localStorage.getItem("pref-theme") === "dark") {
        document.querySelector("html").dataset.theme = 'dark';
    } else if (localStorage.getItem("pref-theme") === "light") {
       document.querySelector("html").dataset.theme = 'light';
    } else if (window.matchMedia('(prefers-color-scheme: dark)').matches) {
        document.querySelector("html").dataset.theme = 'dark';
    } else {
        document.querySelector("html").dataset.theme = 'light';
    }

</script><meta property="og:url" content="https://neilyuan0404.github.io/zh/blog/tcp/">
  <meta property="og:site_name" content="Neil&#39;s Digital Garden">
  <meta property="og:title" content="实现TCP发送HTTP请求">
  <meta property="og:description" content="HTTP协议是最被广泛使用的网络传输协议，所有的www文件都必须遵守这个标准，并且，HTTP基于TCP/IP通信协议来传递数据，本文的主要内容是介绍HTTP请求的的格式，并且使用C语言以TCP的方式来实现请求的发送。">
  <meta property="og:locale" content="zh-cn">
  <meta property="og:type" content="article">
    <meta property="article:section" content="blog">
    <meta property="article:published_time" content="2025-12-28T12:45:38+08:00">
    <meta property="article:modified_time" content="2025-12-28T12:45:38+08:00">
    <meta property="article:tag" content="TCP">
    <meta property="article:tag" content="HTTP">
    <meta property="article:tag" content="网络编程">
    <meta property="article:tag" content="C语言">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="实现TCP发送HTTP请求">
<meta name="twitter:description" content="HTTP协议是最被广泛使用的网络传输协议，所有的www文件都必须遵守这个标准，并且，HTTP基于TCP/IP通信协议来传递数据，本文的主要内容是介绍HTTP请求的的格式，并且使用C语言以TCP的方式来实现请求的发送。">


<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BreadcrumbList",
  "itemListElement": [
    {
      "@type": "ListItem",
      "position":  1 ,
      "name": "Blogs",
      "item": "https://neilyuan0404.github.io/zh/blog/"
    }, 
    {
      "@type": "ListItem",
      "position":  2 ,
      "name": "实现TCP发送HTTP请求",
      "item": "https://neilyuan0404.github.io/zh/blog/tcp/"
    }
  ]
}
</script>
<script type="application/ld+json">
{
  "@context": "https://schema.org",
  "@type": "BlogPosting",
  "headline": "实现TCP发送HTTP请求",
  "name": "实现TCP发送HTTP请求",
  "description": "HTTP协议是最被广泛使用的网络传输协议，所有的www文件都必须遵守这个标准，并且，HTTP基于TCP/IP通信协议来传递数据，本文的主要内容是介绍HTTP请求的的格式，并且使用C语言以TCP的方式来实现请求的发送。\n",
  "keywords": [
    "TCP", "HTTP", "网络编程", "C语言"
  ],
  "articleBody": "HTTP协议是最被广泛使用的网络传输协议，所有的www文件都必须遵守这个标准，并且，HTTP基于TCP/IP通信协议来传递数据，本文的主要内容是介绍HTTP请求的的格式，并且使用C语言以TCP的方式来实现请求的发送。\n创建套接字 HTTP协议是应用层的协议，而其传输接口层的实现需要通过创建套接字。\n1int http_create_socket(char *ip) { 2 3 int sockfd = socket(AF_INET, SOCK_STREAM, 0); 4 5 struct sockaddr_in sin = {0}; 6 sin.sin_family = AF_INET; 7 sin.sin_port = htons(80);//http协议默认是80端口 8 sin.sin_addr.s_addr = inet_addr(ip);//将char*转化为无符号int 9 10 if (0 != connect(sockfd, (struct sockaddr*)\u0026sin, sizeof(struct sockaddr_in))) { 11 return -1; 12 } 13 14 fcntl(sockfd, F_SETFL, O_NONBLOCK);//设置为非阻塞 15 16 return sockfd; 17} 关键技术阐述：上述代码的第3行调用socket函数用以创建套接字描述符，其中第一个参数指定使用IPv4， 第二个参数SOCK_STREAM指定后，默认使用TCP（而不是UDP）协议进行传输，第三个参数一般是具体协议选择，设置为0让系统自行决定即可。\n5～12行为相对固定的编程套路，填充好套接字地址sockaddr_in这个结构体的相关内容，与本文相关唯一值得注意的点是，HTTP默认使用80端口。\n第14行使用fcntl（file control函数）将连接设置为非阻塞。如果socket是阻塞的，read（）的时候整个程序挂起，等待io数据到来，反之则不会。使用到的时候查询下这个函数的参数如何设置即可，不需要特别记忆。\nHTTP请求报文的一般格式 发送http请求的函数实现如下 1char* http_send_request(const char *hostname, const char *resource) { 2 3 char *ip = host_to_ip(hostname); 4 int sockfd = http_create_socket(ip); 5 6 char buffer[BUFFER_SIZE] = {0}; 7 sprintf(buffer, 8\t\"GET %s %s\\r\\n\\ 9\tHost: %s\\r\\n\\ 10\t%s\\r\\n\\ 11\t\\r\\n\", 12\tresource, HTTP_VERSION, 13\thostname, 14\tCONNECTION_TYPE 15\t); 16 17 send(sockfd, buffer, strlen(buffer), 0); 18 19 //select负责检测网络io里面有没有可读的数据 20 fd_set fdread; 21 FD_ZERO(\u0026fdread); //描述符集置空 22 FD_SET(sockfd, \u0026fdread); 23 24 struct timeval tv; 25 tv.tv_sec = 5; 26 tv.tv_usec = 0; 27 28 char *result = malloc(sizeof(int)); 29 memset(result, 0, sizeof(int)); 30 31 while (1) { 32 //用法：select(maxfd+1, \u0026rset, \u0026wset, \u0026eset, NULL); 33 int selection = select(sockfd+1, \u0026fdread, NULL, NULL, \u0026tv); 34 if (!selection || !FD_ISSET((sockfd), \u0026fdread)) { 35 break; 36 } else { 37 memset(buffer, 0, BUFFER_SIZE); 38 int len = recv(sockfd, buffer, BUFFER_SIZE, 0); 39 if (len == 0) { 40\tbreak; 41 } 42 43 result = realloc(result, (strlen(result) + len + 1)); 44 strncat(result, buffer, len); 45 } 46 } 47 return result; 48} 关键技术阐述：第6～15行：像TCP这种协议，数据的传输是一串一串的发送和到来的，更准确的描述是数据流，所以为了应对数据流断断续续到达的情况，需要使用到缓冲区buffer。而http请求内容符合我们上面那张图的格式即可。这里我们为了可读性和可维护性，使用了两个define：\n#define HTTP_VERSION \"HTTP/1.1\" #define CONNECTION_TYPE \"Connection: close\\r\\n\" 19～22行，之前讲过，本文中采用的是非阻塞的实现（read的时候不会挂起，系统继续其他的工作），所以我们可以搭配使用select函数（用于监听socket描述符）实现事件驱动，避免了忙轮询占用大量系统资源。有关细节可以看我的另一篇文章：CSAPP网络编程章节实验：Proxylab\n第24～26行设置了一个超时的时间为5s，超过这个时间断开连接。避免无意义的等待。\n第31～41行用while（1）循环反复读取服务器响应的内容，直到len等于0读取完毕打破循环退出。\n",
  "wordCount" : "1205",
  "inLanguage": "zh",
  "datePublished": "2025-12-28T12:45:38+08:00",
  "dateModified": "2025-12-28T12:45:38+08:00",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "https://neilyuan0404.github.io/zh/blog/tcp/"
  },
  "publisher": {
    "@type": "Organization",
    "name": "Neil's Digital Garden",
    "logo": {
      "@type": "ImageObject",
      "url": "https://neilyuan0404.github.io/favicon.ico"
    }
  }
}
</script>
</head>
<body id="top">
    <header class="header">
    <nav class="nav">
        <div class="logo">
            <a href="https://neilyuan0404.github.io/zh/" accesskey="h" title="Neil&#39;s Digital Garden (Alt + H)">Neil&#39;s Digital Garden</a>
            <div class="logo-switches">
                <button id="theme-toggle" accesskey="t" title="(Alt + T)" aria-label="Toggle theme">
                    <svg id="moon" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <path d="M21 12.79A9 9 0 1 1 11.21 3 7 7 0 0 0 21 12.79z"></path>
                    </svg>
                    <svg id="sun" xmlns="http://www.w3.org/2000/svg" width="24" height="18" viewBox="0 0 24 24"
                        fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round"
                        stroke-linejoin="round">
                        <circle cx="12" cy="12" r="5"></circle>
                        <line x1="12" y1="1" x2="12" y2="3"></line>
                        <line x1="12" y1="21" x2="12" y2="23"></line>
                        <line x1="4.22" y1="4.22" x2="5.64" y2="5.64"></line>
                        <line x1="18.36" y1="18.36" x2="19.78" y2="19.78"></line>
                        <line x1="1" y1="12" x2="3" y2="12"></line>
                        <line x1="21" y1="12" x2="23" y2="12"></line>
                        <line x1="4.22" y1="19.78" x2="5.64" y2="18.36"></line>
                        <line x1="18.36" y1="5.64" x2="19.78" y2="4.22"></line>
                    </svg>
                </button>
                    <ul class="lang-switch"><li>|</li>
                        <li>
                            <a href="https://neilyuan0404.github.io/en/" title="English"
                                aria-label="English">En</a>
                        </li>
                    </ul>
            </div>
        </div>
        <ul id="menu">
            <li>
                <a href="https://neilyuan0404.github.io/zh/" title="Blogs">
                    <span>Blogs</span>
                </a>
            </li>
            <li>
                <a href="https://neilyuan0404.github.io/zh/tags/" title="Tags">
                    <span>Tags</span>
                </a>
            </li>
            <li>
                <a href="https://neilyuan0404.github.io/zh/archives/" title="Archives">
                    <span>Archives</span>
                </a>
            </li>
            <li>
                <a href="https://neilyuan0404.github.io/zh/about/" title="About">
                    <span>About</span>
                </a>
            </li>
        </ul>
    </nav>
</header>
<main class="main">

<article class="post-single">
  <header class="post-header">
    
    <h1 class="post-title entry-hint-parent">
      实现TCP发送HTTP请求
    </h1>
    <div class="post-meta"><span title='2025-12-28 12:45:38 +0800 CST'>2025年12月28日</span>

</div>
  </header> 
  <div class="post-content"><p>HTTP协议是最被广泛使用的网络传输协议，所有的www文件都必须遵守这个标准，并且，HTTP基于TCP/IP通信协议来传递数据，本文的主要内容是介绍HTTP请求的的格式，并且使用C语言以TCP的方式来实现请求的发送。</p>
<h2 id="创建套接字">创建套接字<a hidden class="anchor" aria-hidden="true" href="#创建套接字">#</a></h2>
<p>HTTP协议是应用层的协议，而其传输接口层的实现需要通过创建套接字。</p>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-http.c" data-lang="http.c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">int</span> <span class="nf">http_create_socket</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">ip</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="nf">socket</span><span class="p">(</span><span class="n">AF_INET</span><span class="p">,</span> <span class="n">SOCK_STREAM</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">  <span class="k">struct</span> <span class="n">sockaddr_in</span> <span class="n">sin</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="n">sin</span><span class="p">.</span><span class="n">sin_family</span> <span class="o">=</span> <span class="n">AF_INET</span><span class="p">;</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="n">sin</span><span class="p">.</span><span class="n">sin_port</span> <span class="o">=</span> <span class="nf">htons</span><span class="p">(</span><span class="mi">80</span><span class="p">);</span><span class="c1">//http协议默认是80端口
</span></span></span><span class="line"><span class="ln"> 8</span><span class="cl">  <span class="n">sin</span><span class="p">.</span><span class="n">sin_addr</span><span class="p">.</span><span class="n">s_addr</span> <span class="o">=</span> <span class="nf">inet_addr</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span><span class="c1">//将char*转化为无符号int
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl">
</span></span><span class="line"><span class="ln">10</span><span class="cl">  <span class="k">if</span> <span class="p">(</span><span class="mi">0</span> <span class="o">!=</span> <span class="nf">connect</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">sin</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="k">struct</span> <span class="n">sockaddr_in</span><span class="p">)))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">11</span><span class="cl">    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">
</span></span><span class="line"><span class="ln">14</span><span class="cl">  <span class="nf">fcntl</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">F_SETFL</span><span class="p">,</span> <span class="n">O_NONBLOCK</span><span class="p">);</span><span class="c1">//设置为非阻塞
</span></span></span><span class="line"><span class="ln">15</span><span class="cl">  
</span></span><span class="line"><span class="ln">16</span><span class="cl">  <span class="k">return</span> <span class="n">sockfd</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">17</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>关键技术阐述</strong>：上述代码的第3行调用socket函数用以创建套接字描述符，其中第一个参数指定使用IPv4， 第二个参数SOCK_STREAM指定后，默认使用TCP（而不是UDP）协议进行传输，第三个参数一般是具体协议选择，设置为0让系统自行决定即可。</p>
<p>5～12行为相对固定的编程套路，填充好套接字地址sockaddr_in这个结构体的相关内容，与本文相关唯一值得注意的点是，HTTP默认使用80端口。</p>
<p>第14行使用fcntl（file control函数）将连接设置为非阻塞。如果socket是阻塞的，read（）的时候整个程序挂起，等待io数据到来，反之则不会。使用到的时候查询下这个函数的参数如何设置即可，不需要特别记忆。</p>
<h2 id="http请求报文的一般格式">HTTP请求报文的一般格式<a hidden class="anchor" aria-hidden="true" href="#http请求报文的一般格式">#</a></h2>
<p><img alt="HTTP请求报文的一般格式" loading="lazy" src="/images/http_header.png"></p>
<h4 id="发送http请求的函数实现如下">发送http请求的函数实现如下<a hidden class="anchor" aria-hidden="true" href="#发送http请求的函数实现如下">#</a></h4>
<div class="highlight"><pre tabindex="0" class="chroma"><code class="language-http.c" data-lang="http.c"><span class="line"><span class="ln"> 1</span><span class="cl"><span class="kt">char</span><span class="o">*</span> <span class="nf">http_send_request</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">hostname</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">resource</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln"> 2</span><span class="cl">
</span></span><span class="line"><span class="ln"> 3</span><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">ip</span> <span class="o">=</span> <span class="nf">host_to_ip</span><span class="p">(</span><span class="n">hostname</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 4</span><span class="cl">  <span class="kt">int</span> <span class="n">sockfd</span> <span class="o">=</span> <span class="nf">http_create_socket</span><span class="p">(</span><span class="n">ip</span><span class="p">);</span>
</span></span><span class="line"><span class="ln"> 5</span><span class="cl">
</span></span><span class="line"><span class="ln"> 6</span><span class="cl">  <span class="kt">char</span> <span class="n">buffer</span><span class="p">[</span><span class="n">BUFFER_SIZE</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">0</span><span class="p">};</span>
</span></span><span class="line"><span class="ln"> 7</span><span class="cl">  <span class="nf">sprintf</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span>
</span></span><span class="line"><span class="ln"> 8</span><span class="cl">	  <span class="s">&#34;GET %s %s</span><span class="se">\r\n</span><span class="s">\
</span></span></span><span class="line"><span class="ln"> 9</span><span class="cl"><span class="s">	  Host: %s</span><span class="se">\r\n</span><span class="s">\
</span></span></span><span class="line"><span class="ln">10</span><span class="cl"><span class="s">	  %s</span><span class="se">\r\n</span><span class="s">\
</span></span></span><span class="line"><span class="ln">11</span><span class="cl"><span class="s">	  </span><span class="se">\r\n</span><span class="s">&#34;</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">12</span><span class="cl">	  <span class="n">resource</span><span class="p">,</span> <span class="n">HTTP_VERSION</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">13</span><span class="cl">	  <span class="n">hostname</span><span class="p">,</span>
</span></span><span class="line"><span class="ln">14</span><span class="cl">	  <span class="n">CONNECTION_TYPE</span>
</span></span><span class="line"><span class="ln">15</span><span class="cl">	  <span class="p">);</span>
</span></span><span class="line"><span class="ln">16</span><span class="cl">
</span></span><span class="line"><span class="ln">17</span><span class="cl">  <span class="nf">send</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="nf">strlen</span><span class="p">(</span><span class="n">buffer</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">18</span><span class="cl">
</span></span><span class="line"><span class="ln">19</span><span class="cl">  <span class="c1">//select负责检测网络io里面有没有可读的数据
</span></span></span><span class="line"><span class="ln">20</span><span class="cl">  <span class="n">fd_set</span> <span class="n">fdread</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">21</span><span class="cl">  <span class="nf">FD_ZERO</span><span class="p">(</span><span class="o">&amp;</span><span class="n">fdread</span><span class="p">);</span> <span class="c1">//描述符集置空
</span></span></span><span class="line"><span class="ln">22</span><span class="cl">  <span class="nf">FD_SET</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdread</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">23</span><span class="cl">
</span></span><span class="line"><span class="ln">24</span><span class="cl">  <span class="k">struct</span> <span class="n">timeval</span> <span class="n">tv</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">25</span><span class="cl">  <span class="n">tv</span><span class="p">.</span><span class="n">tv_sec</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">26</span><span class="cl">  <span class="n">tv</span><span class="p">.</span><span class="n">tv_usec</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">27</span><span class="cl">
</span></span><span class="line"><span class="ln">28</span><span class="cl">  <span class="kt">char</span> <span class="o">*</span><span class="n">result</span> <span class="o">=</span> <span class="nf">malloc</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">29</span><span class="cl">  <span class="nf">memset</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">30</span><span class="cl">  
</span></span><span class="line"><span class="ln">31</span><span class="cl">  <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">32</span><span class="cl">    <span class="c1">//用法：select(maxfd+1, &amp;rset, &amp;wset, &amp;eset, NULL);
</span></span></span><span class="line"><span class="ln">33</span><span class="cl">    <span class="kt">int</span> <span class="n">selection</span> <span class="o">=</span> <span class="nf">select</span><span class="p">(</span><span class="n">sockfd</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">fdread</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="nb">NULL</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">tv</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">34</span><span class="cl">    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">selection</span> <span class="o">||</span> <span class="o">!</span><span class="nf">FD_ISSET</span><span class="p">((</span><span class="n">sockfd</span><span class="p">),</span> <span class="o">&amp;</span><span class="n">fdread</span><span class="p">))</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">35</span><span class="cl">      <span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">36</span><span class="cl">    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">37</span><span class="cl">      <span class="nf">memset</span><span class="p">(</span><span class="n">buffer</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">38</span><span class="cl">      <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="nf">recv</span><span class="p">(</span><span class="n">sockfd</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">BUFFER_SIZE</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">39</span><span class="cl">      <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
</span></span><span class="line"><span class="ln">40</span><span class="cl">	<span class="k">break</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">41</span><span class="cl">      <span class="p">}</span>
</span></span><span class="line"><span class="ln">42</span><span class="cl">
</span></span><span class="line"><span class="ln">43</span><span class="cl">      <span class="n">result</span> <span class="o">=</span> <span class="nf">realloc</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="p">(</span><span class="nf">strlen</span><span class="p">(</span><span class="n">result</span><span class="p">)</span> <span class="o">+</span> <span class="n">len</span> <span class="o">+</span> <span class="mi">1</span><span class="p">));</span>
</span></span><span class="line"><span class="ln">44</span><span class="cl">      <span class="nf">strncat</span><span class="p">(</span><span class="n">result</span><span class="p">,</span> <span class="n">buffer</span><span class="p">,</span> <span class="n">len</span><span class="p">);</span>
</span></span><span class="line"><span class="ln">45</span><span class="cl">    <span class="p">}</span>
</span></span><span class="line"><span class="ln">46</span><span class="cl">  <span class="p">}</span>
</span></span><span class="line"><span class="ln">47</span><span class="cl">  <span class="k">return</span> <span class="n">result</span><span class="p">;</span>
</span></span><span class="line"><span class="ln">48</span><span class="cl"><span class="p">}</span>
</span></span></code></pre></div><p><strong>关键技术阐述</strong>：第6～15行：像TCP这种协议，数据的传输是一串一串的发送和到来的，更准确的描述是数据流，所以为了应对数据流断断续续到达的情况，需要使用到缓冲区buffer。而http请求内容符合我们上面那张图的格式即可。这里我们为了可读性和可维护性，使用了两个define：</p>
<pre><code>#define HTTP_VERSION &quot;HTTP/1.1&quot;
#define CONNECTION_TYPE &quot;Connection: close\r\n&quot;
</code></pre>
<p>19～22行，之前讲过，本文中采用的是非阻塞的实现（read的时候不会挂起，系统继续其他的工作），所以我们可以搭配使用select函数（用于监听socket描述符）实现事件驱动，避免了忙轮询占用大量系统资源。有关细节可以看我的另一篇文章：<a href="https://juejin.cn/post/7570058831559131171">CSAPP网络编程章节实验：Proxylab</a></p>
<p>第24～26行设置了一个超时的时间为5s，超过这个时间断开连接。避免无意义的等待。</p>
<p>第31～41行用while（1）循环反复读取服务器响应的内容，直到len等于0读取完毕打破循环退出。</p>


  </div>

  <footer class="post-footer">
    <ul class="post-tags">
      <li><a href="https://neilyuan0404.github.io/zh/tags/tcp/">TCP</a></li>
      <li><a href="https://neilyuan0404.github.io/zh/tags/http/">HTTP</a></li>
      <li><a href="https://neilyuan0404.github.io/zh/tags/%E7%BD%91%E7%BB%9C%E7%BC%96%E7%A8%8B/">网络编程</a></li>
      <li><a href="https://neilyuan0404.github.io/zh/tags/c%E8%AF%AD%E8%A8%80/">C语言</a></li>
    </ul>
  </footer>
</article>
    </main>
    
<footer class="footer">
        <span>&copy; 2026 <a href="https://neilyuan0404.github.io/zh/">Neil&#39;s Digital Garden</a></span> · 

    <span>
        Powered by
        <a href="https://gohugo.io/" rel="noopener noreferrer" target="_blank">Hugo</a> &
        <a href="https://github.com/adityatelange/hugo-PaperMod/" rel="noopener" target="_blank">PaperMod</a>
    </span>
</footer>
<a href="#top" aria-label="go to top" title="Go to Top (Alt + G)" class="top-link" id="top-link" accesskey="g">
    <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 12 6" fill="currentColor">
        <path d="M12 6H0l6-6z" />
    </svg>
</a>

<script>
    let menu = document.getElementById('menu');
    if (menu) {
        
        const scrollPosition = localStorage.getItem("menu-scroll-position");
        if (scrollPosition) {
            menu.scrollLeft = parseInt(scrollPosition, 10);
        }
        
        menu.onscroll = function () {
            localStorage.setItem("menu-scroll-position", menu.scrollLeft);
        }
    }

    document.querySelectorAll('a[href^="#"]').forEach(anchor => {
        anchor.addEventListener("click", function (e) {
            e.preventDefault();
            var id = this.getAttribute("href").substr(1);
            if (!window.matchMedia('(prefers-reduced-motion: reduce)').matches) {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView({
                    behavior: "smooth"
                });
            } else {
                document.querySelector(`[id='${decodeURIComponent(id)}']`).scrollIntoView();
            }
            if (id === "top") {
                history.replaceState(null, null, " ");
            } else {
                history.pushState(null, null, `#${id}`);
            }
        });
    });

</script>
<script>
    var mybutton = document.getElementById("top-link");
    window.onscroll = function () {
        if (document.body.scrollTop > 800 || document.documentElement.scrollTop > 800) {
            mybutton.style.visibility = "visible";
            mybutton.style.opacity = "1";
        } else {
            mybutton.style.visibility = "hidden";
            mybutton.style.opacity = "0";
        }
    };

</script>
<script>
    document.getElementById("theme-toggle").addEventListener("click", () => {
        const html = document.querySelector("html");
        if (html.dataset.theme === "dark") {
            html.dataset.theme = 'light';
            localStorage.setItem("pref-theme", 'light');
        } else {
            html.dataset.theme = 'dark';
            localStorage.setItem("pref-theme", 'dark');
        }
    })

</script>
</body>

</html>
