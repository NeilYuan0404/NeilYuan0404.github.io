<!doctype html><html lang=zh dir=auto data-theme=auto><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge"><meta name=viewport content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name=robots content="index, follow"><title>一文带你搞清楚什么是线程池 | Home</title><meta name=keywords content="线程池,并发编程,C语言"><meta name=description content="内容简介
1.线程池介绍：
当客户端并发请求服务器的时候，服务器的响应是通过创建线程的方式来实现的。但是当并发的请求过于密集的时候，比如同时有十万个客户端请求服务，创建这些线程的开销是不可接受的：按照POSIX标准，一个线程占用8M的空间， 也就是说1G（1024M）的内存只能接受创建128个线程，假设一个服务器的内存是16G，同时也只能够接受创建2048个线程。这对于十万个客户端请求来说，简直是杯水车薪。所以我们需要&mdash;-线程池。"><meta name=author content><link rel=canonical href=https://NeilYuan0404.github.io/zh/blog/threadpool/><link crossorigin=anonymous href=/assets/css/stylesheet.343cc480b9ffc8f04ccbe5e968ad674880cab773ec19905e93033065c1e7a804.css integrity="sha256-NDzEgLn/yPBMy+XpaK1nSIDKt3PsGZBekwMwZcHnqAQ=" rel="preload stylesheet" as=style><link rel=icon href=https://NeilYuan0404.github.io/favicon.ico><link rel=icon type=image/png sizes=16x16 href=https://NeilYuan0404.github.io/favicon-16x16.png><link rel=icon type=image/png sizes=32x32 href=https://NeilYuan0404.github.io/favicon-32x32.png><link rel=apple-touch-icon href=https://NeilYuan0404.github.io/apple-touch-icon.png><link rel=mask-icon href=https://NeilYuan0404.github.io/safari-pinned-tab.svg><meta name=theme-color content="#2e2e33"><meta name=msapplication-TileColor content="#2e2e33"><link rel=alternate hreflang=zh href=https://NeilYuan0404.github.io/zh/blog/threadpool/><noscript><style>#theme-toggle,.top-link{display:none}</style><style>@media(prefers-color-scheme:dark){:root{--theme:rgb(29, 30, 32);--entry:rgb(46, 46, 51);--primary:rgb(218, 218, 219);--secondary:rgb(155, 156, 157);--tertiary:rgb(65, 66, 68);--content:rgb(196, 196, 197);--code-block-bg:rgb(46, 46, 51);--code-bg:rgb(55, 56, 62);--border:rgb(51, 51, 51);color-scheme:dark}.list{background:var(--theme)}.toc{background:var(--entry)}}@media(prefers-color-scheme:light){.list::-webkit-scrollbar-thumb{border-color:var(--code-bg)}}</style></noscript><script>localStorage.getItem("pref-theme")==="dark"?document.querySelector("html").dataset.theme="dark":localStorage.getItem("pref-theme")==="light"?document.querySelector("html").dataset.theme="light":window.matchMedia("(prefers-color-scheme: dark)").matches?document.querySelector("html").dataset.theme="dark":document.querySelector("html").dataset.theme="light"</script><meta property="og:url" content="https://NeilYuan0404.github.io/zh/blog/threadpool/"><meta property="og:site_name" content="Home"><meta property="og:title" content="一文带你搞清楚什么是线程池"><meta property="og:description" content="内容简介 1.线程池介绍：
当客户端并发请求服务器的时候，服务器的响应是通过创建线程的方式来实现的。但是当并发的请求过于密集的时候，比如同时有十万个客户端请求服务，创建这些线程的开销是不可接受的：按照POSIX标准，一个线程占用8M的空间， 也就是说1G（1024M）的内存只能接受创建128个线程，假设一个服务器的内存是16G，同时也只能够接受创建2048个线程。这对于十万个客户端请求来说，简直是杯水车薪。所以我们需要—-线程池。"><meta property="og:locale" content="zh-cn"><meta property="og:type" content="article"><meta property="article:section" content="blog"><meta property="article:published_time" content="2025-11-21T12:29:21+08:00"><meta property="article:modified_time" content="2025-11-21T12:29:21+08:00"><meta property="article:tag" content="线程池"><meta property="article:tag" content="并发编程"><meta property="article:tag" content="C语言"><meta name=twitter:card content="summary"><meta name=twitter:title content="一文带你搞清楚什么是线程池"><meta name=twitter:description content="内容简介
1.线程池介绍：
当客户端并发请求服务器的时候，服务器的响应是通过创建线程的方式来实现的。但是当并发的请求过于密集的时候，比如同时有十万个客户端请求服务，创建这些线程的开销是不可接受的：按照POSIX标准，一个线程占用8M的空间， 也就是说1G（1024M）的内存只能接受创建128个线程，假设一个服务器的内存是16G，同时也只能够接受创建2048个线程。这对于十万个客户端请求来说，简直是杯水车薪。所以我们需要&mdash;-线程池。"><script type=application/ld+json>{"@context":"https://schema.org","@type":"BreadcrumbList","itemListElement":[{"@type":"ListItem","position":1,"name":"Blogs","item":"https://NeilYuan0404.github.io/zh/blog/"},{"@type":"ListItem","position":2,"name":"一文带你搞清楚什么是线程池","item":"https://NeilYuan0404.github.io/zh/blog/threadpool/"}]}</script><script type=application/ld+json>{"@context":"https://schema.org","@type":"BlogPosting","headline":"一文带你搞清楚什么是线程池","name":"一文带你搞清楚什么是线程池","description":"内容简介 1.线程池介绍：\n当客户端并发请求服务器的时候，服务器的响应是通过创建线程的方式来实现的。但是当并发的请求过于密集的时候，比如同时有十万个客户端请求服务，创建这些线程的开销是不可接受的：按照POSIX标准，一个线程占用8M的空间， 也就是说1G（1024M）的内存只能接受创建128个线程，假设一个服务器的内存是16G，同时也只能够接受创建2048个线程。这对于十万个客户端请求来说，简直是杯水车薪。所以我们需要\u0026mdash;-线程池。\n","keywords":["线程池","并发编程","C语言"],"articleBody":"内容简介 1.线程池介绍：\n当客户端并发请求服务器的时候，服务器的响应是通过创建线程的方式来实现的。但是当并发的请求过于密集的时候，比如同时有十万个客户端请求服务，创建这些线程的开销是不可接受的：按照POSIX标准，一个线程占用8M的空间， 也就是说1G（1024M）的内存只能接受创建128个线程，假设一个服务器的内存是16G，同时也只能够接受创建2048个线程。这对于十万个客户端请求来说，简直是杯水车薪。所以我们需要—-线程池。\n2.线程池的好处：\n避免线程太多，使得内存耗尽 避免创建线程与销毁线程多产生的代价 任务与执行分离 3.线程池原理\n客户端请求被加入任务队列（FIFO）等待，线程池通过锁和条件变量通信机制，让任务队列的任务有序进入执行队列，而执行队列创建线程来有序执行这些任务。那么问题来了，何谓有序？\n先来后到，管理组件负责推送任务 一个线程执行一个任务 当修改底层数据结构的的时候（访问共享资源），不能发生竞争 基于C的线程池实现 代码自取：Github - ThreadPool.c\n支持层：双向链表构造任务队列和执行队列、定义线程池（管理组件）的数据结构 对于线程池的任务队列、执行队列两个组成部分，实现中都采用了简单的双向链表的底层数据结构。\n1//任务队列的结构体 2 struct nTask { 3 void (*task_func) (void *arg); 4 void *user_data; 5 6 struct nTask *prev; 7 struct nTack *next; 8}; 在以上代码的第三行，我们在任务队列中声明一个函数指针，便于需要执行的时候跳转到合适的处理函数。\n1//执行队列的结构体 2struct nWorker { 3 pthread_t threadid; 4 5 int terminate; //终止标识 6 struct nManager *manager; 7 8 struct nWorker *prev; 9 struct nWorker *next; 10}; 以上代码中，terminate：终止标识设置为1的时候，意味着需要退出执行循环。\n1//管理组件的结构体 2typedef struct nManager { 3 struct nTask *tasks; 4 struct nWorker *workers; 5 6 pthread_mutex_t mutex; 7 pthread_cond_t cond; //条件变量 8} TreadPool; 比较有意思的是第6行所定义的互斥锁和第7行所定义的条件变量：这是线程池实现线程同步的关键\n全局一把互斥锁—-访问共享资源的操作需要先取得锁 全局唯一条件变量—-作用是通知有任务在等待，需要唤醒一个线程 接口层：实现如下接口功能 线程池回调：nThreadPoolCallBack 线程池创建：nThreadPoolCreate 线程池销毁：nThreadPoolDestory 推送到任务队列：nThreadPoolPushTask 线程池创建函数：线程池创建一定数量的线程（thread）用于执行(worker)， 这里的实现是线程池使用两个for循环分别创建执行队列和对应的线程（用threadid来唯一标识）。在对执行队列进行任何修改之前，都需要上锁防止竞争。\n1int nThreadPoolCreate(ThreadPool *pool,int numWorkers) { 2 if (pool == NULL) return -1; 3 if (numWorkers \u003c 1) numWorkers = 1; 4 memset(pool, 0, sizeof(ThreadPool)); 5 6 pthread_cond_t blank_cond = PTHREAD_COND_INITIALIZER; 7 memcpy(\u0026pool-\u003econd, \u0026blank_cond, sizeof(pthread_cond_t)); 8 9 pthread_mutex_init(\u0026pool-\u003emutex, NULL); 10 11 int i = 0; 12 for (i = 0;i \u003c numWorkers;i++) { 13 struct nWorker *worker =(struct nWorker*)malloc(sizeof(struct nWorker)); 14 if (worker == NULL) { 15 perror(\"malloc\"); 16 return -2; 17 } 18 memset(worker, 0, sizeof(struct nWorker)); 19 worker-\u003emanager = pool; 20 21 int ret = pthread_create(\u0026worker-\u003ethreadid, NULL, nThreadPoolCallBack, worker); 22 if (ret) { 23 perror(\"pthread_create\"); 24 free(worker); 25 return -3; 26 } 27 LIST_INSERT(worker, pool-\u003eworkers); 28 } 29 printf(\"call_back\\n\"); 30 return 0; 31} 推送到任务队列：一个任务被创建的时候，应该有一个接口函数用于将此任务放到任务队列当中，同样，在使用宏LIST_INSERT修改任务队列的时候需要先加锁保护，防止竞争。重点是，第六行使用了pthread_cond_signal这个函数用于唤醒一个线程，这是实现同步的关键机制。\n1int nThreadPoolPushTask(ThreadPool *pool, struct nTask *tasks) { 2 pthread_mutex_lock(\u0026pool-\u003emutex); 3 4 LIST_INSERT(tasks, pool-\u003etasks); 5 6 pthread_cond_signal(\u0026pool-\u003econd);//唤醒一个等待这个条件的线程 7 8 pthread_mutex_unlock(\u0026pool-\u003emutex); 9 10 return 0; 11} 回调函数：这是线程池中的消费者，是一个while（1）循环。由于涉及LIST_REOMVE删除任务队列中队列的操作，所以需要先获取锁，但是这时我们并不清楚线程目前是否可以被执行，所以在第9行调用了pthread_cond_wait来达成：\n释放锁，为了不在等待的时候一直占用唯一的互斥锁 等待此cond条件变量的线程一旦唤醒，重新获取锁。 将执行的任务从任务队列中删去，while（1）循环在terminate被置位的时候break退出，调用task_func实际执行。\n1//线程回调函数 2static void *nThreadPoolCallBack(void *arg) { 3 struct nWorker *worker = (struct nWorker*)arg; 4 5 while (1) { 6 pthread_mutex_lock(\u0026worker-\u003emanager-\u003emutex); 7 while (worker-\u003emanager-\u003etasks == NULL) { 8 if (worker-\u003eterminate) break; 9 pthread_cond_wait(\u0026worker-\u003emanager-\u003econd, \u0026worker-\u003emanager-\u003emutex); 10 } 11 //避免死锁 12 if (worker-\u003eterminate) { 13 pthread_mutex_unlock(\u0026worker-\u003emanager-\u003emutex); 14 break; 15 } 16 17 struct nTask *task = worker-\u003emanager-\u003etasks; 18 LIST_REMOVE(task, worker-\u003emanager-\u003etasks); 19 20 pthread_mutex_unlock(\u0026worker-\u003emanager-\u003emutex); 21 22 task-\u003etask_func(task); 23 } 24 25 free(worker); 26 27 return NULL; 28} 业务层：其实所谓的业务就是创建很多线程，测试线程池是否正常运作 1void task_entry(struct nTask *task) { 2 //struct nTask *task = (struct nTask*)task; 3 int idx = *(int *)task-\u003euser_data; 4 5 printf(\"idx:%d\\n\", idx); 6 7 free(task-\u003euser_data); 8 free(task); 9} 10 11int main(void) { 12 ThreadPool pool; 13 14 nThreadPoolCreate(\u0026pool,THREADPOOL_INIT_COUNT); 15 printf(\"nThreadPoolCreate -- finish\\n\"); 16 17 int i = 0; 18 for (i = 0;i \u003c TASK_INIT_SIZE;i++) { 19 struct nTask *task = (struct nTask*)malloc(sizeof(struct nTask)); 20 if (task == NULL) { 21 perror(\"malloc\"); 22 exit(1); 23 } 24 memset(task, 0, sizeof(struct nTask)); 25 26 task-\u003etask_func = task_entry; 27 task-\u003euser_data = malloc(sizeof(int)); 28 29 *(int *)task-\u003euser_data = i; 30 31 nThreadPoolPushTask(\u0026pool, task); 32 } 33 34 getchar(); 35} 值得注意的是memset函数的使用是将一块内存区域的内容复制到另一内存当中，但是在这里由于第二个参数为0，所以起到的实际作用是将task所指向结构体的内容全部置为所对应的0值，起到实际上的初始化效果。\n","wordCount":"1932","inLanguage":"zh","datePublished":"2025-11-21T12:29:21+08:00","dateModified":"2025-11-21T12:29:21+08:00","mainEntityOfPage":{"@type":"WebPage","@id":"https://NeilYuan0404.github.io/zh/blog/threadpool/"},"publisher":{"@type":"Organization","name":"Home","logo":{"@type":"ImageObject","url":"https://NeilYuan0404.github.io/favicon.ico"}}}</script></head><body id=top><header class=header><nav class=nav><div class=logo><a href=https://NeilYuan0404.github.io/zh/ accesskey=h title="Home (Alt + H)">Home</a><div class=logo-switches><button id=theme-toggle accesskey=t title="(Alt + T)" aria-label="Toggle theme">
<svg id="moon" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><path d="M21 12.79A9 9 0 1111.21 3 7 7 0 0021 12.79z"/></svg>
<svg id="sun" width="24" height="18" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round"><circle cx="12" cy="12" r="5"/><line x1="12" y1="1" x2="12" y2="3"/><line x1="12" y1="21" x2="12" y2="23"/><line x1="4.22" y1="4.22" x2="5.64" y2="5.64"/><line x1="18.36" y1="18.36" x2="19.78" y2="19.78"/><line x1="1" y1="12" x2="3" y2="12"/><line x1="21" y1="12" x2="23" y2="12"/><line x1="4.22" y1="19.78" x2="5.64" y2="18.36"/><line x1="18.36" y1="5.64" x2="19.78" y2="4.22"/></svg></button><ul class=lang-switch><li>|</li><li><a href=https://NeilYuan0404.github.io/en/ title=English aria-label=English>En</a></li></ul></div></div><ul id=menu><li><a href=https://NeilYuan0404.github.io/zh/ title=主页><span>主页</span></a></li><li><a href=https://NeilYuan0404.github.io/zh/tags/ title=标签><span>标签</span></a></li><li><a href=https://NeilYuan0404.github.io/zh/archives/ title=归档><span>归档</span></a></li><li><a href=https://NeilYuan0404.github.io/zh/about/ title=关于><span>关于</span></a></li></ul></nav></header><main class=main><article class=post-single><header class=post-header><h1 class="post-title entry-hint-parent">一文带你搞清楚什么是线程池</h1><div class=post-meta><span title='2025-11-21 12:29:21 +0800 CST'>2025年11月21日</span></div></header><div class=post-content><h2 id=内容简介>内容简介<a hidden class=anchor aria-hidden=true href=#内容简介>#</a></h2><p>1.线程池介绍：</p><p>当客户端并发请求服务器的时候，服务器的响应是通过创建线程的方式来实现的。但是当并发的请求过于密集的时候，比如同时有十万个客户端请求服务，创建这些线程的开销是不可接受的：按照POSIX标准，一个线程占用8M的空间， 也就是说1G（1024M）的内存只能接受创建128个线程，假设一个服务器的内存是16G，同时也只能够接受创建2048个线程。这对于十万个客户端请求来说，简直是杯水车薪。所以我们需要&mdash;-线程池。</p><p>2.线程池的好处：</p><ul><li>避免线程太多，使得内存耗尽</li><li>避免创建线程与销毁线程多产生的代价</li><li>任务与执行分离</li></ul><p>3.线程池原理</p><p>客户端请求被加入任务队列（FIFO）等待，线程池通过锁和条件变量通信机制，让任务队列的任务有序进入执行队列，而执行队列创建线程来有序执行这些任务。那么问题来了，何谓有序？</p><ul><li>先来后到，管理组件负责推送任务</li><li>一个线程执行一个任务</li><li>当修改底层数据结构的的时候（访问共享资源），不能发生竞争</li></ul><hr><h3 id=基于c的线程池实现>基于C的线程池实现<a hidden class=anchor aria-hidden=true href=#基于c的线程池实现>#</a></h3><p>代码自取：<a href=https://github.com/NeilYuan0404/Toys/blob/main/ThreadPool.c>Github - ThreadPool.c</a></p><h4 id=支持层双向链表构造任务队列和执行队列定义线程池管理组件的数据结构>支持层：双向链表构造任务队列和执行队列、定义线程池（管理组件）的数据结构<a hidden class=anchor aria-hidden=true href=#支持层双向链表构造任务队列和执行队列定义线程池管理组件的数据结构>#</a></h4><p>对于线程池的任务队列、执行队列两个组成部分，实现中都采用了简单的双向链表的底层数据结构。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ThreadPool.c data-lang=ThreadPool.c><span class=line><span class=ln>1</span><span class=cl><span class=c1>//任务队列的结构体
</span></span></span><span class=line><span class=ln>2</span><span class=cl> <span class=k>struct</span> <span class=n>nTask</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>  <span class=kt>void</span> <span class=p>(</span><span class=o>*</span><span class=n>task_func</span><span class=p>)</span> <span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>);</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>  <span class=kt>void</span> <span class=o>*</span><span class=n>user_data</span><span class=p>;</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>
</span></span><span class=line><span class=ln>6</span><span class=cl>  <span class=k>struct</span> <span class=n>nTask</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=ln>7</span><span class=cl>  <span class=k>struct</span> <span class=n>nTack</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=ln>8</span><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>在以上代码的第三行，我们在任务队列中声明一个函数指针，便于需要执行的时候跳转到合适的处理函数。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ThreadPool.c data-lang=ThreadPool.c><span class=line><span class=ln> 1</span><span class=cl><span class=c1>//执行队列的结构体
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=k>struct</span> <span class=n>nWorker</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>  <span class=kt>pthread_t</span> <span class=n>threadid</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>
</span></span><span class=line><span class=ln> 5</span><span class=cl>  <span class=kt>int</span> <span class=n>terminate</span><span class=p>;</span> <span class=c1>//终止标识
</span></span></span><span class=line><span class=ln> 6</span><span class=cl>  <span class=k>struct</span> <span class=n>nManager</span> <span class=o>*</span><span class=n>manager</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>  
</span></span><span class=line><span class=ln> 8</span><span class=cl>  <span class=k>struct</span> <span class=n>nWorker</span> <span class=o>*</span><span class=n>prev</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>  <span class=k>struct</span> <span class=n>nWorker</span> <span class=o>*</span><span class=n>next</span><span class=p>;</span>
</span></span><span class=line><span class=ln>10</span><span class=cl><span class=p>};</span>
</span></span></code></pre></div><p>以上代码中，terminate：终止标识设置为1的时候，意味着需要退出执行循环。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ThreadPool.c data-lang=ThreadPool.c><span class=line><span class=ln>1</span><span class=cl><span class=c1>//管理组件的结构体
</span></span></span><span class=line><span class=ln>2</span><span class=cl><span class=k>typedef</span> <span class=k>struct</span> <span class=n>nManager</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>3</span><span class=cl>  <span class=k>struct</span> <span class=n>nTask</span> <span class=o>*</span><span class=n>tasks</span><span class=p>;</span>
</span></span><span class=line><span class=ln>4</span><span class=cl>  <span class=k>struct</span> <span class=n>nWorker</span> <span class=o>*</span><span class=n>workers</span><span class=p>;</span>
</span></span><span class=line><span class=ln>5</span><span class=cl>
</span></span><span class=line><span class=ln>6</span><span class=cl>  <span class=kt>pthread_mutex_t</span> <span class=n>mutex</span><span class=p>;</span>
</span></span><span class=line><span class=ln>7</span><span class=cl>  <span class=kt>pthread_cond_t</span> <span class=n>cond</span><span class=p>;</span> <span class=c1>//条件变量
</span></span></span><span class=line><span class=ln>8</span><span class=cl><span class=p>}</span> <span class=n>TreadPool</span><span class=p>;</span>
</span></span></code></pre></div><p>比较有意思的是第6行所定义的互斥锁和第7行所定义的条件变量：这是线程池实现线程同步的关键</p><ul><li>全局一把互斥锁&mdash;-访问共享资源的操作需要先取得锁</li><li>全局唯一条件变量&mdash;-作用是通知有任务在等待，需要唤醒一个线程</li></ul><h4 id=接口层实现如下接口功能>接口层：实现如下接口功能<a hidden class=anchor aria-hidden=true href=#接口层实现如下接口功能>#</a></h4><ul><li>线程池回调：nThreadPoolCallBack</li><li>线程池创建：nThreadPoolCreate</li><li>线程池销毁：nThreadPoolDestory</li><li>推送到任务队列：nThreadPoolPushTask</li></ul><p>线程池创建函数：线程池创建<strong>一定数量</strong>的线程（thread）用于执行(worker)， 这里的实现是线程池使用两个for循环分别创建执行队列和对应的线程（用threadid来唯一标识）。在对执行队列进行任何修改之前，都需要上锁防止竞争。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ThreadPool.c data-lang=ThreadPool.c><span class=line><span class=ln> 1</span><span class=cl><span class=kt>int</span> <span class=nf>nThreadPoolCreate</span><span class=p>(</span><span class=n>ThreadPool</span> <span class=o>*</span><span class=n>pool</span><span class=p>,</span><span class=kt>int</span> <span class=n>numWorkers</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>pool</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=k>return</span> <span class=o>-</span><span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>  <span class=k>if</span> <span class=p>(</span><span class=n>numWorkers</span> <span class=o>&lt;</span> <span class=mi>1</span><span class=p>)</span> <span class=n>numWorkers</span> <span class=o>=</span> <span class=mi>1</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>  <span class=nf>memset</span><span class=p>(</span><span class=n>pool</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=n>ThreadPool</span><span class=p>));</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>
</span></span><span class=line><span class=ln> 6</span><span class=cl>  <span class=kt>pthread_cond_t</span> <span class=n>blank_cond</span> <span class=o>=</span> <span class=n>PTHREAD_COND_INITIALIZER</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>  <span class=nf>memcpy</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pool</span><span class=o>-&gt;</span><span class=n>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>blank_cond</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=kt>pthread_cond_t</span><span class=p>));</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>
</span></span><span class=line><span class=ln> 9</span><span class=cl>  <span class=nf>pthread_mutex_init</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pool</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>
</span></span><span class=line><span class=ln>11</span><span class=cl>  <span class=kt>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>numWorkers</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>    <span class=k>struct</span> <span class=n>nWorker</span> <span class=o>*</span><span class=n>worker</span> <span class=o>=</span><span class=p>(</span><span class=k>struct</span> <span class=n>nWorker</span><span class=o>*</span><span class=p>)</span><span class=nf>malloc</span><span class=p>(</span><span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>nWorker</span><span class=p>));</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>worker</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>      <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;malloc&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>2</span><span class=p>;</span>
</span></span><span class=line><span class=ln>17</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>    <span class=nf>memset</span><span class=p>(</span><span class=n>worker</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=k>sizeof</span><span class=p>(</span><span class=k>struct</span> <span class=n>nWorker</span><span class=p>));</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>    <span class=n>worker</span><span class=o>-&gt;</span><span class=n>manager</span> <span class=o>=</span> <span class=n>pool</span><span class=p>;</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>
</span></span><span class=line><span class=ln>21</span><span class=cl>    <span class=kt>int</span> <span class=n>ret</span> <span class=o>=</span> <span class=nf>pthread_create</span><span class=p>(</span><span class=o>&amp;</span><span class=n>worker</span><span class=o>-&gt;</span><span class=n>threadid</span><span class=p>,</span> <span class=nb>NULL</span><span class=p>,</span> <span class=n>nThreadPoolCallBack</span><span class=p>,</span> <span class=n>worker</span><span class=p>);</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>ret</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>      <span class=nf>perror</span><span class=p>(</span><span class=s>&#34;pthread_create&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>      <span class=nf>free</span><span class=p>(</span><span class=n>worker</span><span class=p>);</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>      <span class=k>return</span> <span class=o>-</span><span class=mi>3</span><span class=p>;</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>27</span><span class=cl>    <span class=nf>LIST_INSERT</span><span class=p>(</span><span class=n>worker</span><span class=p>,</span> <span class=n>pool</span><span class=o>-&gt;</span><span class=n>workers</span><span class=p>);</span>
</span></span><span class=line><span class=ln>28</span><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=ln>29</span><span class=cl>  <span class=nf>printf</span><span class=p>(</span><span class=s>&#34;call_back</span><span class=se>\n</span><span class=s>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>30</span><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>31</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>推送到任务队列：一个任务被创建的时候，应该有一个接口函数用于将此任务放到任务队列当中，同样，在使用宏<code>LIST_INSERT</code>修改任务队列的时候需要先加锁保护，防止竞争。重点是，第六行使用了<code>pthread_cond_signal</code>这个函数用于唤醒一个线程，这是实现同步的关键机制。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ThreadPool.c data-lang=ThreadPool.c><span class=line><span class=ln> 1</span><span class=cl><span class=kt>int</span> <span class=nf>nThreadPoolPushTask</span><span class=p>(</span><span class=n>ThreadPool</span> <span class=o>*</span><span class=n>pool</span><span class=p>,</span> <span class=k>struct</span> <span class=n>nTask</span> <span class=o>*</span><span class=n>tasks</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>  <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pool</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>
</span></span><span class=line><span class=ln> 4</span><span class=cl>  <span class=nf>LIST_INSERT</span><span class=p>(</span><span class=n>tasks</span><span class=p>,</span> <span class=n>pool</span><span class=o>-&gt;</span><span class=n>tasks</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 5</span><span class=cl>
</span></span><span class=line><span class=ln> 6</span><span class=cl>  <span class=nf>pthread_cond_signal</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pool</span><span class=o>-&gt;</span><span class=n>cond</span><span class=p>);</span><span class=c1>//唤醒一个等待这个条件的线程
</span></span></span><span class=line><span class=ln> 7</span><span class=cl>  
</span></span><span class=line><span class=ln> 8</span><span class=cl>  <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pool</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>
</span></span><span class=line><span class=ln>10</span><span class=cl>  <span class=k>return</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>11</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>回调函数：这是线程池中的消费者，是一个while（1）循环。由于涉及<code>LIST_REOMVE</code>删除任务队列中队列的操作，所以需要先获取锁，但是这时我们并不清楚线程目前是否可以被执行，所以在第9行调用了<code>pthread_cond_wait</code>来达成：</p><ul><li>释放锁，为了不在等待的时候一直占用唯一的互斥锁</li><li>等待此cond条件变量的线程一旦唤醒，重新获取锁。</li></ul><p>将执行的任务从任务队列中删去，while（1）循环在terminate被置位的时候break退出，调用task_func实际执行。</p><div class=highlight><pre tabindex=0 class=chroma><code class=language-ThreadPool.c data-lang=ThreadPool.c><span class=line><span class=ln> 1</span><span class=cl><span class=c1>//线程回调函数
</span></span></span><span class=line><span class=ln> 2</span><span class=cl><span class=k>static</span> <span class=kt>void</span> <span class=o>*</span><span class=nf>nThreadPoolCallBack</span><span class=p>(</span><span class=kt>void</span> <span class=o>*</span><span class=n>arg</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>  <span class=k>struct</span> <span class=n>nWorker</span> <span class=o>*</span><span class=n>worker</span> <span class=o>=</span> <span class=p>(</span><span class=k>struct</span> <span class=n>nWorker</span><span class=o>*</span><span class=p>)</span><span class=n>arg</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>
</span></span><span class=line><span class=ln> 5</span><span class=cl>  <span class=k>while</span> <span class=p>(</span><span class=mi>1</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>    <span class=nf>pthread_mutex_lock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>worker</span><span class=o>-&gt;</span><span class=n>manager</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 7</span><span class=cl>    <span class=k>while</span> <span class=p>(</span><span class=n>worker</span><span class=o>-&gt;</span><span class=n>manager</span><span class=o>-&gt;</span><span class=n>tasks</span> <span class=o>==</span> <span class=nb>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>      <span class=k>if</span> <span class=p>(</span><span class=n>worker</span><span class=o>-&gt;</span><span class=n>terminate</span><span class=p>)</span> <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl>      <span class=nf>pthread_cond_wait</span><span class=p>(</span><span class=o>&amp;</span><span class=n>worker</span><span class=o>-&gt;</span><span class=n>manager</span><span class=o>-&gt;</span><span class=n>cond</span><span class=p>,</span> <span class=o>&amp;</span><span class=n>worker</span><span class=o>-&gt;</span><span class=n>manager</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>11</span><span class=cl>    <span class=c1>//避免死锁
</span></span></span><span class=line><span class=ln>12</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>worker</span><span class=o>-&gt;</span><span class=n>terminate</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>      <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>worker</span><span class=o>-&gt;</span><span class=n>manager</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=ln>14</span><span class=cl>      <span class=k>break</span><span class=p>;</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>
</span></span><span class=line><span class=ln>17</span><span class=cl>    <span class=k>struct</span> <span class=n>nTask</span> <span class=o>*</span><span class=n>task</span> <span class=o>=</span> <span class=n>worker</span><span class=o>-&gt;</span><span class=n>manager</span><span class=o>-&gt;</span><span class=n>tasks</span><span class=p>;</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>    <span class=nf>LIST_REMOVE</span><span class=p>(</span><span class=n>task</span><span class=p>,</span> <span class=n>worker</span><span class=o>-&gt;</span><span class=n>manager</span><span class=o>-&gt;</span><span class=n>tasks</span><span class=p>);</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>
</span></span><span class=line><span class=ln>20</span><span class=cl>    <span class=nf>pthread_mutex_unlock</span><span class=p>(</span><span class=o>&amp;</span><span class=n>worker</span><span class=o>-&gt;</span><span class=n>manager</span><span class=o>-&gt;</span><span class=n>mutex</span><span class=p>);</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>
</span></span><span class=line><span class=ln>22</span><span class=cl>    <span class=n>task</span><span class=o>-&gt;</span><span class=nf>task_func</span><span class=p>(</span><span class=n>task</span><span class=p>);</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>
</span></span><span class=line><span class=ln>25</span><span class=cl>  <span class=nf>free</span><span class=p>(</span><span class=n>worker</span><span class=p>);</span>
</span></span><span class=line><span class=ln>26</span><span class=cl>
</span></span><span class=line><span class=ln>27</span><span class=cl>  <span class=k>return</span> <span class=nb>NULL</span><span class=p>;</span>
</span></span><span class=line><span class=ln>28</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><h4 id=业务层其实所谓的业务就是创建很多线程测试线程池是否正常运作>业务层：其实所谓的业务就是创建很多线程，测试线程池是否正常运作<a hidden class=anchor aria-hidden=true href=#业务层其实所谓的业务就是创建很多线程测试线程池是否正常运作>#</a></h4><div class=highlight><pre tabindex=0 class=chroma><code class=language-gdscript3 data-lang=gdscript3><span class=line><span class=ln> 1</span><span class=cl><span class=n>void</span> <span class=n>task_entry</span><span class=p>(</span><span class=n>struct</span> <span class=n>nTask</span> <span class=o>*</span><span class=n>task</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln> 2</span><span class=cl>  <span class=o>//</span><span class=n>struct</span> <span class=n>nTask</span> <span class=o>*</span><span class=n>task</span> <span class=o>=</span> <span class=p>(</span><span class=n>struct</span> <span class=n>nTask</span><span class=o>*</span><span class=p>)</span><span class=n>task</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 3</span><span class=cl>  <span class=ne>int</span> <span class=n>idx</span> <span class=o>=</span> <span class=o>*</span><span class=p>(</span><span class=ne>int</span> <span class=o>*</span><span class=p>)</span><span class=n>task</span><span class=o>-&gt;</span><span class=n>user_data</span><span class=p>;</span>
</span></span><span class=line><span class=ln> 4</span><span class=cl>
</span></span><span class=line><span class=ln> 5</span><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;idx:</span><span class=si>%d</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>,</span> <span class=n>idx</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 6</span><span class=cl>
</span></span><span class=line><span class=ln> 7</span><span class=cl>  <span class=n>free</span><span class=p>(</span><span class=n>task</span><span class=o>-&gt;</span><span class=n>user_data</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 8</span><span class=cl>  <span class=n>free</span><span class=p>(</span><span class=n>task</span><span class=p>);</span>
</span></span><span class=line><span class=ln> 9</span><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=ln>10</span><span class=cl>
</span></span><span class=line><span class=ln>11</span><span class=cl><span class=ne>int</span> <span class=n>main</span><span class=p>(</span><span class=n>void</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>12</span><span class=cl>  <span class=n>ThreadPool</span> <span class=n>pool</span><span class=p>;</span>
</span></span><span class=line><span class=ln>13</span><span class=cl>
</span></span><span class=line><span class=ln>14</span><span class=cl>  <span class=n>nThreadPoolCreate</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pool</span><span class=p>,</span><span class=n>THREADPOOL_INIT_COUNT</span><span class=p>);</span>
</span></span><span class=line><span class=ln>15</span><span class=cl>  <span class=n>printf</span><span class=p>(</span><span class=s2>&#34;nThreadPoolCreate -- finish</span><span class=se>\n</span><span class=s2>&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>16</span><span class=cl>
</span></span><span class=line><span class=ln>17</span><span class=cl>  <span class=ne>int</span> <span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span>
</span></span><span class=line><span class=ln>18</span><span class=cl>  <span class=k>for</span> <span class=p>(</span><span class=n>i</span> <span class=o>=</span> <span class=mi>0</span><span class=p>;</span><span class=n>i</span> <span class=o>&lt;</span> <span class=n>TASK_INIT_SIZE</span><span class=p>;</span><span class=n>i</span><span class=o>++</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>19</span><span class=cl>    <span class=n>struct</span> <span class=n>nTask</span> <span class=o>*</span><span class=n>task</span> <span class=o>=</span> <span class=p>(</span><span class=n>struct</span> <span class=n>nTask</span><span class=o>*</span><span class=p>)</span><span class=n>malloc</span><span class=p>(</span><span class=n>sizeof</span><span class=p>(</span><span class=n>struct</span> <span class=n>nTask</span><span class=p>));</span>
</span></span><span class=line><span class=ln>20</span><span class=cl>    <span class=k>if</span> <span class=p>(</span><span class=n>task</span> <span class=o>==</span> <span class=n>NULL</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=ln>21</span><span class=cl>      <span class=n>perror</span><span class=p>(</span><span class=s2>&#34;malloc&#34;</span><span class=p>);</span>
</span></span><span class=line><span class=ln>22</span><span class=cl>      <span class=n>exit</span><span class=p>(</span><span class=mi>1</span><span class=p>);</span>
</span></span><span class=line><span class=ln>23</span><span class=cl>    <span class=p>}</span>
</span></span><span class=line><span class=ln>24</span><span class=cl>    <span class=n>memset</span><span class=p>(</span><span class=n>task</span><span class=p>,</span> <span class=mi>0</span><span class=p>,</span> <span class=n>sizeof</span><span class=p>(</span><span class=n>struct</span> <span class=n>nTask</span><span class=p>));</span>
</span></span><span class=line><span class=ln>25</span><span class=cl>
</span></span><span class=line><span class=ln>26</span><span class=cl>    <span class=n>task</span><span class=o>-&gt;</span><span class=n>task_func</span> <span class=o>=</span> <span class=n>task_entry</span><span class=p>;</span>
</span></span><span class=line><span class=ln>27</span><span class=cl>    <span class=n>task</span><span class=o>-&gt;</span><span class=n>user_data</span> <span class=o>=</span> <span class=n>malloc</span><span class=p>(</span><span class=n>sizeof</span><span class=p>(</span><span class=ne>int</span><span class=p>));</span>
</span></span><span class=line><span class=ln>28</span><span class=cl>
</span></span><span class=line><span class=ln>29</span><span class=cl>    <span class=o>*</span><span class=p>(</span><span class=ne>int</span> <span class=o>*</span><span class=p>)</span><span class=n>task</span><span class=o>-&gt;</span><span class=n>user_data</span> <span class=o>=</span> <span class=n>i</span><span class=p>;</span>
</span></span><span class=line><span class=ln>30</span><span class=cl>
</span></span><span class=line><span class=ln>31</span><span class=cl>    <span class=n>nThreadPoolPushTask</span><span class=p>(</span><span class=o>&amp;</span><span class=n>pool</span><span class=p>,</span> <span class=n>task</span><span class=p>);</span>
</span></span><span class=line><span class=ln>32</span><span class=cl>  <span class=p>}</span>
</span></span><span class=line><span class=ln>33</span><span class=cl>
</span></span><span class=line><span class=ln>34</span><span class=cl>  <span class=n>getchar</span><span class=p>();</span>
</span></span><span class=line><span class=ln>35</span><span class=cl><span class=p>}</span>
</span></span></code></pre></div><p>值得注意的是memset函数的使用是将一块内存区域的内容复制到另一内存当中，但是在这里由于第二个参数为0，所以起到的实际作用是将task所指向结构体的内容全部置为所对应的0值，起到实际上的初始化效果。</p></div><footer class=post-footer><ul class=post-tags><li><a href=https://NeilYuan0404.github.io/zh/tags/%E7%BA%BF%E7%A8%8B%E6%B1%A0/>线程池</a></li><li><a href=https://NeilYuan0404.github.io/zh/tags/%E5%B9%B6%E5%8F%91%E7%BC%96%E7%A8%8B/>并发编程</a></li><li><a href=https://NeilYuan0404.github.io/zh/tags/c%E8%AF%AD%E8%A8%80/>C语言</a></li></ul></footer></article></main><footer class=footer><span>&copy; 2026 <a href=https://NeilYuan0404.github.io/zh/>Home</a></span> ·
<span>Powered by
<a href=https://gohugo.io/ rel="noopener noreferrer" target=_blank>Hugo</a> &
<a href=https://github.com/adityatelange/hugo-PaperMod/ rel=noopener target=_blank>PaperMod</a></span></footer><a href=#top aria-label="go to top" title="Go to Top (Alt + G)" class=top-link id=top-link accesskey=g><svg viewBox="0 0 12 6" fill="currentColor"><path d="M12 6H0l6-6z"/></svg>
</a><script>let menu=document.getElementById("menu");if(menu){const e=localStorage.getItem("menu-scroll-position");e&&(menu.scrollLeft=parseInt(e,10)),menu.onscroll=function(){localStorage.setItem("menu-scroll-position",menu.scrollLeft)}}document.querySelectorAll('a[href^="#"]').forEach(e=>{e.addEventListener("click",function(e){e.preventDefault();var t=this.getAttribute("href").substr(1);window.matchMedia("(prefers-reduced-motion: reduce)").matches?document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView():document.querySelector(`[id='${decodeURIComponent(t)}']`).scrollIntoView({behavior:"smooth"}),t==="top"?history.replaceState(null,null," "):history.pushState(null,null,`#${t}`)})})</script><script>var mybutton=document.getElementById("top-link");window.onscroll=function(){document.body.scrollTop>800||document.documentElement.scrollTop>800?(mybutton.style.visibility="visible",mybutton.style.opacity="1"):(mybutton.style.visibility="hidden",mybutton.style.opacity="0")}</script><script>document.getElementById("theme-toggle").addEventListener("click",()=>{const e=document.querySelector("html");e.dataset.theme==="dark"?(e.dataset.theme="light",localStorage.setItem("pref-theme","light")):(e.dataset.theme="dark",localStorage.setItem("pref-theme","dark"))})</script></body></html>